<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced25 Blockchain Tracker PoC</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        /* Custom font */
        body { font-family: 'Inter', sans-serif; /* Ensure Inter is loaded or use a common sans-serif */ }

        /* Base button styling */
        .btn {
            @apply inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-150;
        }
        .btn-primary { @apply bg-sky-600 hover:bg-sky-700 focus:ring-sky-500; }
        .btn-secondary { @apply bg-emerald-500 hover:bg-emerald-600 focus:ring-emerald-400; }
        .btn-neutral { @apply bg-slate-500 hover:bg-slate-600 focus:ring-slate-400; }
        .btn-disabled { @apply bg-slate-300 hover:bg-slate-300 cursor-not-allowed; }

        .input-field {
            @apply block w-full px-4 py-3 rounded-md border-slate-300 shadow-sm focus:border-sky-500 focus:ring focus:ring-sky-500 focus:ring-opacity-50 placeholder-slate-400 text-sm;
        }
        .card {
            @apply bg-white shadow-2xl rounded-xl p-6 sm:p-8 mb-8;
        }
        .history-item {
            @apply border-b border-slate-200 py-4;
        }
        .history-item:last-child { @apply border-b-0 pb-0; }
        .history-item p { @apply mb-1; }

        #messageBox {
            @apply fixed top-6 right-6 p-4 rounded-lg shadow-xl text-white z-[100] text-sm transition-all duration-300 ease-in-out transform translate-x-full opacity-0;
        }
        #messageBox.show {
            @apply translate-x-0 opacity-100;
        }
        .message-success { @apply bg-green-500; }
        .message-error { @apply bg-red-600; }
        .message-info { @apply bg-blue-500; }

        .batch-id-list-item {
            @apply block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-sky-100 hover:text-sky-700 rounded-md cursor-pointer transition-colors;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-50 text-slate-900 min-h-screen flex flex-col items-center pt-8 sm:pt-12 pb-20 px-4 selection:bg-sky-200 selection:text-sky-700">

    <div id="messageBox"></div>

    <div class="w-full max-w-3xl">
        <header class="text-center mb-10 sm:mb-12">
            <div class="inline-flex items-center justify-center mb-4">
                 <svg class="h-12 w-12 text-sky-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5V6.75a4.5 4.5 0 119 0v3.75M3.75 21.75h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H3.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z" />
                </svg>
                <h1 class="ml-3 text-4xl sm:text-5xl font-bold text-sky-600 tracking-tight">ChainTrack PoC</h1>
            </div>
            <p class="text-slate-600 mt-1 text-lg">Ethical Supply Chain Verification on the Blockchain (Sepolia Testnet)</p>
        </header>

        <div class="card">
            <h2 class="text-2xl font-semibold mb-3 text-sky-700">Welcome to ChainTrack PoC!</h2>
            <p class="text-slate-600 text-sm leading-relaxed mb-2">
                This Proof-of-Concept demonstrates a simplified blockchain-based supply chain tracking system.
                It allows for the registration of product batches and the recording of their movements or status updates
                on an immutable ledger (the Sepolia Ethereum testnet).
            </p>
            <p class="text-slate-600 text-sm leading-relaxed">
                <strong>How it works:</strong> Connect your MetaMask wallet (on Sepolia network). You can then register new batches with an initial location, or add tracking updates to existing batches. All transactions are recorded on the blockchain. You can view the history of any batch by its ID.
            </p>
             <p class="text-slate-600 text-sm leading-relaxed mt-2">
                <strong>For a Prospective Client:</strong> Imagine this system scaled up. Each product or batch gets a unique digital identity. Every step – from raw material sourcing, manufacturing, shipping, to retail – can be recorded transparently and securely. This enables:
                <ul class="list-disc list-inside ml-4 mt-1 text-slate-600 text-sm">
                    <li>Verification of product authenticity.</li>
                    <li>Proof of ethical sourcing and compliance (e.g., fair labor, conflict-free minerals).</li>
                    <li>Enhanced consumer trust and brand reputation.</li>
                    <li>Improved recall management and supply chain efficiency.</li>
                </ul>
            </p>
        </div>


        <div class="card" id="connectCard">
            <h2 class="text-2xl font-semibold mb-4 text-sky-700">1. Connect Your Wallet</h2>
            <button id="connectButton" class="btn btn-primary w-full text-lg">
                <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a2.25 2.25 0 00-2.25-2.25H15a3 3 0 11-6 0H5.25A2.25 2.25 0 003 12m18 0v6a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 18v-6m18 0V9M3 12V9m18 0a2.25 2.25 0 00-2.25-2.25H5.25A2.25 2.25 0 003 6.75m15.75 0V5.25A2.25 2.25 0 0016.5 3h-9A2.25 2.25 0 005.25 5.25v1.5" /></svg>
                Connect to MetaMask
            </button>
            <p id="connectionStatus" class="mt-4 text-sm text-center text-slate-500">Please connect to the Sepolia Testnet.</p>
        </div>

        <div id="mainAppInterface" class="hidden">
            <div class="card">
                <h2 class="text-2xl font-semibold mb-1 text-sky-700">2. Register or Update Batch</h2>
                <p class="text-sm text-slate-500 mb-6">Enter batch details below. All actions require a transaction on the Sepolia network.</p>

                <div>
                    <label for="batchId" class="block text-sm font-medium text-slate-700 mb-1">Batch ID (Unique Identifier):</label>
                    <input type="text" id="batchId" name="batchId" class="input-field" placeholder="e.g., COFFEE-XYZ-001">
                </div>

                <div class="mt-4">
                    <label for="location" class="block text-sm font-medium text-slate-700 mb-1">Location / Status / Details:</label>
                    <input type="text" id="location" name="location" class="input-field" placeholder="e.g., Origin: Nyeri, Kenya / Warehouse A Scan">
                </div>

                <div class="mt-6 grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <button id="registerButton" class="btn btn-primary w-full">Register New Batch</button>
                    <button id="updateButton" class="btn btn-secondary w-full">Add Tracking Update</button>
                </div>
            </div>

            <div class="card">
                <h2 class="text-2xl font-semibold mb-4 text-sky-700">3. Registered Batch IDs</h2>
                <div id="allBatchIdsList" class="max-h-60 overflow-y-auto bg-slate-50 p-3 rounded-md border border-slate-200">
                    <p class="text-slate-500 italic">Loading batch IDs or no batches registered yet...</p>
                </div>
            </div>

            <div class="card">
                <h2 class="text-2xl font-semibold mb-4 text-sky-700">4. View Specific Batch History</h2>
                <div>
                    <label for="viewBatchId" class="block text-sm font-medium text-slate-700 mb-1">Batch ID to View:</label>
                    <input type="text" id="viewBatchId" name="viewBatchId" class="input-field" placeholder="Enter Batch ID or click one from the list above">
                </div>
                <button id="viewHistoryButton" class="btn btn-neutral mt-4 w-full">View History</button>

                <div id="historyOutput" class="mt-6 pt-6 border-t border-slate-200">
                    <p class="text-slate-500 italic">Enter a Batch ID and click "View History" or select from the list above.</p>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center mt-12 mb-6">
        <p class="text-sm text-slate-500">&copy; ${new Date().getFullYear()} ChainTrack PoC. For demonstration purposes only.</p>
    </footer>

    <script>
        // --- Configuration ---
        // Make sure this is your correct deployed TrackerV2 contract address
        const contractAddress = '0xd9145CCE52D386f254917e481eB44e9943F39138'; // Use your actual deployed address
        
        // !!! IMPORTANT: Replace YOUR_NEW_CONTRACT_ABI_HERE with the fresh ABI from Remix !!!
        const contractABI = \`[
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "string",
				"name": "batchId",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "newLocation",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "updatedBy",
				"type": "address"
			}
		],
		"name": "BatchLocationUpdated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "string",
				"name": "batchId",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "initialLocation",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "registeredBy",
				"type": "address"
			}
		],
		"name": "BatchRegistered",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "_newLocation",
				"type": "string"
			}
		],
		"name": "addTrackingUpdate",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "allBatchIds",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "batchHistory",
		"outputs": [
			{
				"internalType": "string",
				"name": "location",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "actor",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getAllBatchIds",
		"outputs": [
			{
				"internalType": "string[]",
				"name": "",
				"type": "string[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			}
		],
		"name": "getBatchHistory",
		"outputs": [
			{
				"components": [
					{
						"internalType": "string",
						"name": "location",
						"type": "string"
					},
					{
						"internalType": "uint256",
						"name": "timestamp",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "actor",
						"type": "address"
					}
				],
				"internalType": "struct TrackerV2.TrackingEvent[]",
				"name": "",
				"type": "tuple[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			}
		],
		"name": "getHistoryCount",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "_initialLocation",
				"type": "string"
			}
		],
		"name": "registerBatch",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
]\`; 

        // --- Global Variables ---
        let provider;
        let signer;
        let contract;
        let userAccount;

        // --- DOM Elements ---
        // These are defined globally. Ensure your HTML has these IDs.
        const connectButton = document.getElementById('connectButton');
        const connectionStatus = document.getElementById('connectionStatus');
        const mainAppInterface = document.getElementById('mainAppInterface');

        const batchIdInput = document.getElementById('batchId');
        const locationInput = document.getElementById('location');
        const registerButton = document.getElementById('registerButton');
        const updateButton = document.getElementById('updateButton');

        const allBatchIdsList = document.getElementById('allBatchIdsList');
        const viewBatchIdInput = document.getElementById('viewBatchId');
        const viewHistoryButton = document.getElementById('viewHistoryButton');
        const historyOutput = document.getElementById('historyOutput');
        const messageBox = document.getElementById('messageBox');

        // --- Functions ---

        function showMessage(text, type = 'info', duration = 5000) {
            if (!messageBox) {
                console.error("showMessage: messageBox element not found.");
                return; 
            }
            messageBox.textContent = text;
            messageBox.className = 'fixed top-6 right-6 p-4 rounded-lg shadow-xl text-white z-[100] text-sm transition-all duration-300 ease-in-out transform opacity-0'; // Reset classes
            
            if (type === 'success') messageBox.classList.add('message-success');
            else if (type === 'error') messageBox.classList.add('message-error');
            else messageBox.classList.add('message-info');
            
            void messageBox.offsetWidth; // Trigger reflow for transition
            messageBox.classList.add('show');

            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        async function connectWallet() {
            if (!connectButton) {
                console.error("connectWallet: connectButton element not found.");
                return; 
            }

            // Prevent re-execution if already connected or button is disabled for other reasons
            if (connectButton.disabled && connectButton.textContent === 'Wallet Connected') {
                 console.log("Wallet already connected and initialized.");
                 return; 
            }
            // If button is disabled but not because it's connected (e.g. MetaMask not detected initially)
            if (connectButton.disabled && connectButton.textContent !== 'Wallet Connected') {
                 console.log("Connect button is disabled. Ensure MetaMask is installed and refresh if needed.");
                 if (typeof window.ethereum === 'undefined') { // Double check MetaMask presence
                    showMessage('MetaMask not detected. Please install MetaMask and refresh.', 'error');
                    return;
                 }
            }

            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    userAccount = accounts[0];
                    
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    
                    let parsedABI;
                    try {
                        // CRITICAL: Check if contractABI is the placeholder. If so, don't try to parse.
                        if (contractABI === 'YOUR_NEW_CONTRACT_ABI_HERE' || !contractABI || !contractABI.trim().startsWith('[')) {
                            console.error("Contract ABI is a placeholder or invalid. Please paste the correct ABI into the HTML script.");
                            showMessage("CRITICAL ERROR: Contract ABI is not set correctly in the code. Please update it.", "error");
                            if(connectButton) { // Keep button disabled or re-disable if it was somehow enabled
                                connectButton.disabled = true;
                                connectButton.classList.remove('btn-primary');
                                connectButton.classList.add('btn-disabled');
                            }
                            return; // Stop execution if ABI is not valid
                        }
                        parsedABI = JSON.parse(contractABI);
                    } catch (e) {
                        console.error("Failed to parse Contract ABI. Ensure it's valid JSON:", e);
                        showMessage("CRITICAL ERROR: Contract ABI is invalid (JSON parse failed). Check console and HTML.", "error");
                        if(connectButton) {
                            connectButton.disabled = true;
                            connectButton.classList.remove('btn-primary');
                            connectButton.classList.add('btn-disabled');
                        }
                        return; // Stop execution
                    }
                    contract = new ethers.Contract(contractAddress, parsedABI, signer);
                    
                    if (connectionStatus) connectionStatus.innerHTML = \`Connected: <span class="font-semibold">\${userAccount.substring(0, 6)}...\${userAccount.substring(userAccount.length - 4)}</span> on Sepolia\`;
                    if (connectButton) {
                        connectButton.textContent = 'Wallet Connected';
                        connectButton.disabled = true;
                        connectButton.classList.remove('btn-primary');
                        connectButton.classList.add('btn-disabled');
                    }
                    
                    const connectCard = document.getElementById('connectCard');
                    if (connectCard) connectCard.classList.add('hidden');
                    if (mainAppInterface) mainAppInterface.classList.remove('hidden');
                    
                    showMessage('Wallet connected successfully!', 'success');

                    await fetchAllBatchIds(); 

                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    window.ethereum.on('chainChanged', handleChainChanged);

                } catch (error) {
                    console.error("User denied account access or error during connectWallet:", error);
                    if (connectionStatus) connectionStatus.textContent = 'Connection failed. Please try again.';
                    showMessage(\`Connection Error: \${error.message || 'User denied access.'}\`, 'error');
                }
            } else {
                if (connectionStatus) connectionStatus.textContent = 'MetaMask is not installed. Please install it to use this app.';
                showMessage('MetaMask not detected. Please install MetaMask and refresh.', 'error');
                if (connectButton) {
                    connectButton.disabled = true; 
                    connectButton.classList.remove('btn-primary');
                    connectButton.classList.add('btn-disabled');
                }
            }
        }

        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                showMessage('Wallet disconnected. Please connect MetaMask.', 'info');
                resetUI();
            } else {
                userAccount = accounts[0];
                if (connectionStatus) connectionStatus.innerHTML = \`Connected: <span class="font-semibold">\${userAccount.substring(0, 6)}...\${userAccount.substring(userAccount.length - 4)}</span> on Sepolia\`;
                if (provider) {
                    signer = provider.getSigner();
                    let parsedABI;
                    try {
                        if (contractABI === 'YOUR_NEW_CONTRACT_ABI_HERE' || !contractABI || !contractABI.trim().startsWith('[')) {
                             console.error("Contract ABI is a placeholder or invalid during accountsChanged.");
                             showMessage("CRITICAL ERROR: Contract ABI is a placeholder or invalid.", "error");
                             return;
                        }
                        parsedABI = JSON.parse(contractABI);
                    } catch (e) {
                        console.error("Failed to parse Contract ABI during accountsChanged:", e);
                        showMessage("CRITICAL ERROR: Contract ABI is invalid. Check console.", "error");
                        return;
                    }
                    contract = new ethers.Contract(contractAddress, parsedABI, signer);
                }
                showMessage('Account changed.', 'info');
                fetchAllBatchIds(); 
            }
        }

        function handleChainChanged(_chainId) {
            showMessage('Network changed. Please ensure you are on Sepolia Testnet and refresh if needed.', 'info');
            window.location.reload();
        }
        
        function resetUI() {
            if (connectButton) {
                connectButton.textContent = 'Connect to MetaMask';
                connectButton.disabled = false;
                connectButton.classList.add('btn-primary');
                connectButton.classList.remove('btn-disabled');
            }
            if (connectionStatus) connectionStatus.textContent = 'Please connect to the Sepolia Testnet.';
            if (mainAppInterface) mainAppInterface.classList.add('hidden');
            const connectCard = document.getElementById('connectCard');
            if (connectCard) connectCard.classList.remove('hidden');
            
            userAccount = null;
            provider = null;
            signer = null;
            contract = null;
        }

        async function registerNewBatch() {
            if (!contract) { showMessage('Please connect your wallet first, and ensure ABI is correct.', 'error'); return; }
            const currentBatchId = batchIdInput ? batchIdInput.value.trim() : "";
            const currentInitialLocation = locationInput ? locationInput.value.trim() : "";

            if (!currentBatchId || !currentInitialLocation) { showMessage('Batch ID and Initial Location are required.', 'error'); return; }

            if (registerButton) {
                registerButton.disabled = true;
                registerButton.textContent = 'Registering...';
            }
            try {
                showMessage('Sending transaction to register batch...', 'info');
                const tx = await contract.registerBatch(currentBatchId, currentInitialLocation);
                await tx.wait();
                showMessage(\`Batch "\${currentBatchId}" registered successfully! Tx: \${tx.hash.substring(0,10)}...\`, 'success');
                if (batchIdInput) batchIdInput.value = '';
                if (locationInput) locationInput.value = '';
                await fetchAllBatchIds(); 
            } catch (error) {
                console.error("Error registering batch:", error);
                let errMsg = error?.data?.message || error?.error?.message || error.message || 'Transaction failed.';
                if (typeof errMsg === 'object') errMsg = JSON.stringify(errMsg); // Handle complex error objects
                if (errMsg.includes("Batch ID already exists")) errMsg = "This Batch ID has already been registered.";
                showMessage(\`Error: \${errMsg}\`, 'error');
            } finally {
                if (registerButton) {
                    registerButton.disabled = false;
                    registerButton.textContent = 'Register New Batch';
                }
            }
        }

        async function addBatchUpdate() {
            if (!contract) { showMessage('Please connect your wallet first, and ensure ABI is correct.', 'error'); return; }
            const currentBatchId = batchIdInput ? batchIdInput.value.trim() : "";
            const currentNewLocation = locationInput ? locationInput.value.trim() : "";

            if (!currentBatchId || !currentNewLocation) { showMessage('Batch ID and New Location are required for an update.', 'error'); return; }
            
            if (updateButton) {
                updateButton.disabled = true;
                updateButton.textContent = 'Updating...';
            }
            try {
                showMessage('Sending transaction to update batch location...', 'info');
                const tx = await contract.addTrackingUpdate(currentBatchId, currentNewLocation);
                await tx.wait();
                showMessage(\`Location for batch "\${currentBatchId}" updated! Tx: \${tx.hash.substring(0,10)}...\`, 'success');
                if (locationInput) locationInput.value = ''; 
                if (viewBatchIdInput && viewBatchIdInput.value.trim() === currentBatchId) {
                    await viewHistory();
                }
            } catch (error) {
                console.error("Error updating batch:", error);
                let errMsg = error?.data?.message || error?.error?.message || error.message || 'Transaction failed.';
                if (typeof errMsg === 'object') errMsg = JSON.stringify(errMsg);
                if (errMsg.includes("Batch ID not found")) errMsg = "Batch ID not found. Register it first.";
                showMessage(\`Error: \${errMsg}\`, 'error');
            } finally {
                if (updateButton) {
                    updateButton.disabled = false;
                    updateButton.textContent = 'Add Tracking Update';
                }
            }
        }
        
        async function fetchAllBatchIds() {
            let tempContract = contract;
            if (!tempContract) {
                 try {
                    // IMPORTANT: Replace YOUR_INFURA_PROJECT_ID with your actual Infura Project ID for read-only access if desired
                    const readProvider = new ethers.providers.JsonRpcProvider(\`https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID\`); 
                    let parsedABI;
                    try {
                        if (contractABI === 'YOUR_NEW_CONTRACT_ABI_HERE' || !contractABI || !contractABI.trim().startsWith('[')) {
                             console.error("Contract ABI is a placeholder or invalid during fetchAllBatchIds.");
                             if (allBatchIdsList) allBatchIdsList.innerHTML = '<p class="text-red-500 italic">CRITICAL ERROR: ABI not set.</p>';
                             return;
                        }
                        parsedABI = JSON.parse(contractABI);
                    } catch (e) {
                        console.error("Failed to parse Contract ABI during fetchAllBatchIds (read-only):", e);
                        if (allBatchIdsList) allBatchIdsList.innerHTML = '<p class="text-red-500 italic">CRITICAL ERROR: ABI invalid (JSON).</p>';
                        return;
                    }
                    tempContract = new ethers.Contract(contractAddress, parsedABI, readProvider);
                } catch(e) {
                    if (allBatchIdsList) allBatchIdsList.innerHTML = '<p class="text-red-500 italic">Could not load batch IDs. Connect wallet or check console for provider errors.</p>';
                    console.error("Error creating read-only provider for fetchAllBatchIds:", e);
                    return;
                }
            }

            try {
                if (allBatchIdsList) allBatchIdsList.innerHTML = '<p class="text-slate-500 italic">Loading batch IDs...</p>';
                const ids = await tempContract.getAllBatchIds(); 
                displayAllBatchIds(ids);
            } catch (error) {
                console.error("Error fetching all batch IDs from contract:", error);
                if (allBatchIdsList) allBatchIdsList.innerHTML = '<p class="text-red-500 italic">Failed to load batch IDs. Ensure wallet is connected to Sepolia and contract is deployed.</p>';
            }
        }

        function displayAllBatchIds(ids) {
            if (!allBatchIdsList) { console.error("displayAllBatchIds: allBatchIdsList element not found."); return; }
            if (!ids || ids.length === 0) { 
                allBatchIdsList.innerHTML = '<p class="text-slate-500 italic">No batches registered yet.</p>';
                return;
            }
            allBatchIdsList.innerHTML = ''; 
            const ul = document.createElement('ul');
            ul.className = 'space-y-1';
            ids.forEach(id => {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = id;
                button.className = 'batch-id-list-item';
                button.onclick = () => {
                    if (viewBatchIdInput) viewBatchIdInput.value = id;
                    viewHistory();
                    const historyOutputEl = document.getElementById('historyOutput');
                    if (historyOutputEl) historyOutputEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                };
                li.appendChild(button);
                ul.appendChild(li);
            });
            allBatchIdsList.appendChild(ul);
        }

        async function viewHistory() {
            let currentReaderContract = contract; 
            const currentViewBatchId = viewBatchIdInput ? viewBatchIdInput.value.trim() : "";

            if (!currentViewBatchId) {
                showMessage('Please enter a Batch ID to view its history.', 'error');
                return;
            }
            
            if (historyOutput) historyOutput.innerHTML = '<p class="text-slate-500 italic">Fetching history...</p>';
            else { console.error("viewHistory: historyOutput element not found."); return; }


            if (!currentReaderContract) {
                try {
                    // IMPORTANT: Replace YOUR_INFURA_PROJECT_ID for read-only access
                    const readProvider = new ethers.providers.JsonRpcProvider(\`https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID\`); 
                    let parsedABI;
                    try {
                        if (contractABI === 'YOUR_NEW_CONTRACT_ABI_HERE' || !contractABI || !contractABI.trim().startsWith('[')) {
                             console.error("Contract ABI is a placeholder or invalid during viewHistory.");
                             if (historyOutput) historyOutput.innerHTML = '<p class="text-red-500">CRITICAL ERROR: ABI not set.</p>';
                             return;
                        }
                        parsedABI = JSON.parse(contractABI);
                    } catch (e) {
                        console.error("Failed to parse Contract ABI during viewHistory (read-only):", e);
                        if (historyOutput) historyOutput.innerHTML = '<p class="text-red-500">CRITICAL ERROR: ABI invalid (JSON).</p>';
                        return;
                    }
                    currentReaderContract = new ethers.Contract(contractAddress, parsedABI, readProvider);
                } catch (e) {
                    console.error("Error creating read-only provider for viewHistory:", e);
                    showMessage('Cannot view history. Wallet not connected and no fallback provider configured.', 'error');
                    if (historyOutput) historyOutput.innerHTML = '<p class="text-red-500">Error: Wallet not connected and no fallback provider (or provider error).</p>';
                    return;
                }
            }

            try {
                const history = await currentReaderContract.getBatchHistory(currentViewBatchId);
                
                if (!history || history.length === 0) { 
                    historyOutput.innerHTML = \`<p class="text-slate-600 font-semibold">No history found for Batch ID: \${currentViewBatchId}</p>\`;
                } else {
                    let html = \`<h3 class="text-xl font-semibold text-sky-600 mb-3">History for Batch ID: \${currentViewBatchId}</h3>\`;
                    history.forEach((event, index) => {
                        html += \`
                            <div class="history-item">
                                <p class="text-sm"><strong class="font-medium text-slate-700">Event \${index + 1}:</strong> \${event.location}</p>
                                <p class="text-xs text-slate-500"><strong>Time:</strong> \${new Date(event.timestamp * 1000).toLocaleString()}</p>
                                <p class="text-xs text-slate-500"><strong>Recorded By:</strong> \${event.actor.substring(0,6)}...\${event.actor.substring(event.actor.length - 4)}</p>
                            </div>
                        \`;
                    });
                    historyOutput.innerHTML = html;
                }
            } catch (error) {
                console.error("Error viewing history from contract:", error);
                showMessage(\`Error viewing history: \${error.message || 'Could not fetch data.'}\`, 'error');
                if (historyOutput) historyOutput.innerHTML = \`<p class="text-red-500">Error fetching history for "\${currentViewBatchId}". Ensure Batch ID is correct and registered.</p>\`;
            }
        }

        // --- Event Listeners ---
        if (connectButton) {
            connectButton.addEventListener('click', connectWallet);
        } else {
            // This console error will appear if the script runs before the button is in the DOM.
            // The window.addEventListener('load', ...) below is designed to handle initial setup.
            console.error("DOM Element 'connectButton' not found during initial script execution for event listener attachment. Will retry on load.");
        }
        // It's good practice to ensure elements exist before adding listeners,
        // though for elements defined directly in HTML, they should be available unless script is in <head> without defer.
        if (registerButton) registerButton.addEventListener('click', registerNewBatch);
        else console.error("DOM Element 'registerButton' not found.");
        
        if (updateButton) updateButton.addEventListener('click', addBatchUpdate);
        else console.error("DOM Element 'updateButton' not found.");

        if (viewHistoryButton) viewHistoryButton.addEventListener('click', viewHistory);
        else console.error("DOM Element 'viewHistoryButton' not found.");


        window.addEventListener('load', () => {
            // Re-fetch critical elements here to ensure DOM is ready
            const localConnectButton = document.getElementById('connectButton');
            const localConnectionStatus = document.getElementById('connectionStatus');

            // If connectButton was not found earlier for event listener, try attaching it now.
            if (localConnectButton && !localConnectButton.hasAttribute('data-listener-attached')) {
                 localConnectButton.addEventListener('click', connectWallet);
                 localConnectButton.setAttribute('data-listener-attached', 'true');
            }


            setTimeout(() => {
                // Ensure elements are re-fetched or checked again if initial global consts might be stale
                const currentConnectButton = document.getElementById('connectButton');
                const currentConnectionStatus = document.getElementById('connectionStatus');


                if (!currentConnectButton || !currentConnectionStatus) {
                    console.error("Connect button or status element not found during final load event timeout. HTML structure might be incorrect or IDs missing.");
                    const body = document.querySelector('body');
                    if (body && !body.querySelector('#critical-error-message')) {
                        const errorDiv = document.createElement('div');
                        errorDiv.id = 'critical-error-message';
                        errorDiv.innerHTML = '<p style="color: red; background: white; padding: 10px; text-align: center; font-weight: bold;">Critical Error: Core UI elements (connect button/status) are missing. Please check the HTML IDs.</p>';
                        body.prepend(errorDiv);
                    }
                    return; 
                }

                if (window.ethereum) {
                    currentConnectionStatus.textContent = 'MetaMask detected. Click the button above to connect.';
                    if (window.ethereum.selectedAddress && window.ethereum.isConnected()) {
                        currentConnectionStatus.innerHTML = \`MetaMask detected. Previously connected as <span class="font-semibold">\${window.ethereum.selectedAddress.substring(0, 6)}...\${window.ethereum.selectedAddress.substring(window.ethereum.selectedAddress.length - 4)}</span>. Click to re-initialize if needed.\`;
                    }
                    currentConnectButton.disabled = false; 
                    currentConnectButton.classList.add('btn-primary');
                    currentConnectButton.classList.remove('btn-disabled');
                } else {
                    currentConnectionStatus.textContent = 'MetaMask not detected. Please install MetaMask and refresh the page.';
                    currentConnectButton.disabled = true; 
                    currentConnectButton.classList.remove('btn-primary');
                    currentConnectButton.classList.add('btn-disabled');
                    if (!document.body.dataset.metaMaskErrorShown) { // Prevent multiple popups
                        showMessage('MetaMask not detected. Please install it and refresh.', 'error');
                        document.body.dataset.metaMaskErrorShown = "true"; 
                    }
                }
            }, 500); // 500ms delay for MetaMask injection
        });
    </script>
</body>
</html>
```

**Key changes in this version of the `<script>` block:**

* **`contractABI` Placeholder:** The line `const contractABI = \`YOUR_NEW_CONTRACT_ABI_HERE\`;` is definitely set to the placeholder.
* **Robust ABI Checks:** The JavaScript functions (`connectWallet`, `handleAccountsChanged`, `fetchAllBatchIds`, `viewHistory`) now have more explicit checks to see if `contractABI` is still the placeholder or an obviously invalid string (e.g., doesn't start with `[`). If it's invalid, it will show a "CRITICAL ERROR" message to the user and log it to the console, preventing further operations that would fail.
* **DOM Element Null Checks:** Added more checks (e.g., `if (!messageBox) return;`) at the beginning of functions that manipulate DOM elements to prevent errors if those elements are somehow not found.
* **Error Message for Missing Core UI:** The `window.addEventListener('load', ...)` function now tries to display a more prominent error if the `connectButton` or `connectionStatus` elements themselves are missing from the HTML.
* **Infura Project ID Placeholder:** Remember to replace `YOUR_INFURA_PROJECT_ID` in `fetchAllBatchIds` and `viewHistory` if you want read-only functionality without a user's wallet connected.

**Instructions:**

1.  **Replace your entire `index.html`** with the code above.
2.  **Carefully copy the ABI** for your `TrackerV2.sol` contract from Remix.
3.  **Paste this ABI** directly between the backticks, replacing `YOUR_NEW_CONTRACT_ABI_HERE`. Ensure no extra characters are introduced.
    ```javascript
    const contractABI = \`[{"inputs": ..., "type": "function"}, ...]\`; // Your pasted ABI goes here
    ```
4.  **Save the `index.html` file.**
5.  **Hard refresh** your browser page (`Ctrl+Shift+R` or `Cmd+Shift+R`).
6.  **Open the developer console (F12).**
    * If you still see "Uncaught SyntaxError: Invalid or unexpected token" and it points to the `contractABI` line, the issue is 100% with the characters you are pasting for the ABI. Try pasting it into a plain text editor first, cleaning it, and then pasting it into the HTML.
    * If you see "CRITICAL ERROR: Contract ABI is not set correctly..." from the `showMessage` function, it means you haven't replaced the placeholder, or what you pasted isn't recognized as a valid start to an ABI.
    * If there are no syntax errors and no critical ABI errors, try clicking "Connect to MetaMask."

This should give you the cleanest slate for pasting the A
