<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethical Supply Chain Tracker PoC</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Lighter gray background */
        }
        .btn {
            @apply bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2.5 px-5 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 ease-in-out transform hover:-translate-y-0.5;
        }
        .btn-secondary {
            @apply bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2.5 px-5 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 ease-in-out transform hover:-translate-y-0.5;
        }
        .input-field {
            @apply mt-1 block w-full px-4 py-2.5 bg-white border border-slate-300 rounded-lg text-sm shadow-sm placeholder-slate-400
                   focus:outline-none focus:border-sky-500 focus:ring-2 focus:ring-sky-500
                   disabled:bg-slate-50 disabled:text-slate-500 disabled:border-slate-200 disabled:shadow-none;
        }
        .card {
            @apply bg-white shadow-2xl rounded-xl p-6 sm:p-8 mb-8; /* Increased shadow and padding */
        }
        .history-item {
            @apply border-b border-gray-200 py-3.5;
        }
        .history-item:last-child {
            @apply border-b-0;
        }
        #messageBox {
            @apply fixed top-6 right-6 p-4 rounded-xl shadow-xl text-white z-[100] text-sm;
        }
        .message-success { @apply bg-green-600; }
        .message-error { @apply bg-red-600; }
        .message-info { @apply bg-blue-600; }

        .batch-id-list-item {
            @apply p-3 mb-2 bg-slate-50 hover:bg-sky-100 rounded-md cursor-pointer transition-colors duration-150 text-sm text-sky-700 font-medium;
        }
        .batch-id-list-item:hover {
            @apply text-sky-800;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
</head>
<body class="text-slate-800 min-h-screen flex flex-col items-center pt-8 sm:pt-12 pb-20 px-4">

    <div id="messageBox" class="hidden opacity-0 transition-opacity duration-300"></div>

    <div class="w-full max-w-3xl">
        <header class="text-center mb-10 sm:mb-12">
            <h1 class="text-4xl sm:text-5xl font-bold text-sky-700">Ethical Supply Chain Tracker</h1>
            <p class="text-slate-600 mt-3 text-base sm:text-lg">A Proof-of-Concept for Transparent & Verifiable Sourcing</p>
        </header>

        <div class="card" id="welcomeSection">
            <h2 class="text-2xl sm:text-3xl font-semibold mb-4 text-sky-700">Welcome to the Tracker!</h2>
            <div class="space-y-3 text-slate-700 text-sm sm:text-base">
                <p>
                    This platform demonstrates how blockchain technology can bring transparency and trust to supply chains.
                    It's designed to track products like cocoa, coffee, diamonds, and textiles, ensuring they meet ethical sourcing standards.
                </p>
                <p><strong class="font-semibold">How it Works:</strong></p>
                <ul class="list-disc list-inside ml-4 space-y-1">
                    <li><strong>Registration:</strong> A unique Batch ID for a set of products is registered on the blockchain with its initial location or status.</li>
                    <li><strong>Tracking Updates:</strong> As the batch moves through the supply chain (e.g., from farm to processor to retailer), each step can be recorded as a new "scan" or update, linked to its Batch ID.</li>
                    <li><strong>Immutable Record:</strong> Each transaction (registration or update) is permanently stored on the blockchain, making it tamper-proof and verifiable by anyone with access.</li>
                    <li><strong>Verification:</strong> Consumers and companies can look up a Batch ID to see its complete journey, verifying its origin and ethical compliance.</li>
                </ul>
                <p><strong class="font-semibold">For Prospective Clients:</strong></p>
                <p>
                    Imagine your customers being able to scan a QR code on a product and instantly see its entire ethical journey, from source to shelf. This PoC showcases the core backend functionality.
                    A full implementation would involve:
                </p>
                 <ul class="list-disc list-inside ml-4 space-y-1">
                    <li>Integration with your existing inventory and logistics systems.</li>
                    <li>User-friendly interfaces for all stakeholders (farmers, auditors, brands, consumers).</li>
                    <li>Robust security measures and potentially private or permissioned blockchain solutions for sensitive data.</li>
                    <li>QR code generation and scanning capabilities.</li>
                </ul>
                <p>This demo uses the <strong class="font-semibold">Sepolia Testnet</strong> (a test version of Ethereum), so all transactions are free and for demonstration purposes only.</p>
            </div>
        </div>

        <div class="card" id="connectCard">
            <h2 class="text-2xl font-semibold mb-4 text-sky-700">1. Connect Your Wallet</h2>
            <p class="text-sm text-slate-500 mb-5">Please connect your MetaMask wallet and ensure you are on the Sepolia Testnet.</p>
            <button id="connectButton" class="btn w-full">Connect to MetaMask</button>
            <p id="connectionStatus" class="mt-4 text-sm text-center text-slate-600">Not Connected.</p>
        </div>

        <div class="grid md:grid-cols-2 md:gap-8">
            <div class="card hidden" id="actionsCard">
                <h2 class="text-2xl font-semibold mb-2 text-sky-700">2. Register or Update</h2>
                <p class="text-sm text-slate-500 mb-6">Enter batch details below.</p>

                <div>
                    <label for="batchId" class="block text-sm font-medium text-slate-700">Batch ID:</label>
                    <input type="text" id="batchId" name="batchId" class="input-field" placeholder="e.g., COCOA-GH-001">
                </div>

                <div class="mt-4">
                    <label for="location" class="block text-sm font-medium text-slate-700">Location/Details:</label>
                    <input type="text" id="location" name="location" class="input-field" placeholder="e.g., Origin: Ashanti Region or Port of Tema Scan">
                </div>

                <div class="mt-6 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                    <button id="registerButton" class="btn flex-1">Register New Batch</button>
                    <button id="updateButton" class="btn-secondary flex-1">Add Tracking Update</button>
                </div>
            </div>

            <div class="card hidden" id="lookupCard">
                 <h2 class="text-2xl font-semibold mb-2 text-sky-700">3. View Batch History</h2>
                 <p class="text-sm text-slate-500 mb-6">Look up a specific Batch ID or select from the list below.</p>
                <div>
                    <label for="viewBatchId" class="block text-sm font-medium text-slate-700">Batch ID to View:</label>
                    <input type="text" id="viewBatchId" name="viewBatchId" class="input-field" placeholder="Enter Batch ID">
                </div>
                <button id="viewHistoryButton" class="btn mt-5 w-full">View History</button>

                <div id="previousBatchIdsSection" class="mt-6 hidden">
                    <h3 class="text-lg font-semibold text-sky-600 mb-3">All Registered Batch IDs:</h3>
                    <div id="previousBatchIdsList" class="max-h-48 overflow-y-auto bg-slate-100 p-3 rounded-md">
                        <p class="text-slate-500 italic text-sm">Loading Batch IDs from blockchain...</p>
                    </div>
                </div>
            </div>
        </div>


        <div class="card hidden" id="historyDisplayCard">
            <h2 class="text-2xl font-semibold mb-4 text-sky-700">Batch Journey</h2>
            <div id="historyOutput" class="mt-2">
                <p class="text-slate-500 italic">Enter a Batch ID and click "View History" or select from the list to see tracking details.</p>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        // IMPORTANT: Replace with your deployed contract address
        const contractAddress = '0xd8b934580fcE35a11B58C6D73aDeE468a2833fa8'; // PASTE YOUR DEPLOYED TrackerV2.sol CONTRACT ADDRESS
        // IMPORTANT: Ensure this ABI matches your deployed TrackerV2.sol, including the getAllBatchIds function
        const contractABI = `[
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "string",
				"name": "batchId",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "newLocation",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "updatedBy",
				"type": "address"
			}
		],
		"name": "BatchLocationUpdated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "string",
				"name": "batchId",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "initialLocation",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "registeredBy",
				"type": "address"
			}
		],
		"name": "BatchRegistered",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "_newLocation",
				"type": "string"
			}
		],
		"name": "addTrackingUpdate",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "allBatchIds",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "batchHistory",
		"outputs": [
			{
				"internalType": "string",
				"name": "location",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "actor",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getAllBatchIds",
		"outputs": [
			{
				"internalType": "string[]",
				"name": "",
				"type": "string[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			}
		],
		"name": "getBatchHistory",
		"outputs": [
			{
				"components": [
					{
						"internalType": "string",
						"name": "location",
						"type": "string"
					},
					{
						"internalType": "uint256",
						"name": "timestamp",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "actor",
						"type": "address"
					}
				],
				"internalType": "struct TrackerV2.TrackingEvent[]",
				"name": "",
				"type": "tuple[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			}
		],
		"name": "getHistoryCount",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "_initialLocation",
				"type": "string"
			}
		],
		"name": "registerBatch",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
]`;

        // --- Global Variables ---
        let provider;
        let signer;
        let contract;
        let userAccount;
        let fetchedBatchIds = []; // Stores batch IDs fetched from the blockchain

        // --- DOM Elements ---
        const connectButton = document.getElementById('connectButton');
        const connectionStatus = document.getElementById('connectionStatus');
        const actionsCard = document.getElementById('actionsCard');
        const lookupCard = document.getElementById('lookupCard');
        const historyDisplayCard = document.getElementById('historyDisplayCard');

        const batchIdInput = document.getElementById('batchId');
        const locationInput = document.getElementById('location');
        const registerButton = document.getElementById('registerButton');
        const updateButton = document.getElementById('updateButton');

        const viewBatchIdInput = document.getElementById('viewBatchId');
        const viewHistoryButton = document.getElementById('viewHistoryButton');
        const historyOutput = document.getElementById('historyOutput');
        const messageBox = document.getElementById('messageBox');

        const previousBatchIdsSection = document.getElementById('previousBatchIdsSection');
        const previousBatchIdsList = document.getElementById('previousBatchIdsList');


        // --- Functions ---

        function showMessage(text, type = 'info', duration = 5000) {
            messageBox.textContent = text;
            messageBox.className = '';
            messageBox.classList.add('fixed', 'top-6', 'right-6', 'p-4', 'rounded-xl', 'shadow-xl', 'text-white', 'z-[100]', 'text-sm', 'transition-opacity', 'duration-300');
            if (type === 'success') messageBox.classList.add('message-success');
            else if (type === 'error') messageBox.classList.add('message-error');
            else messageBox.classList.add('message-info');

            messageBox.classList.remove('hidden', 'opacity-0');
            messageBox.classList.add('opacity-100');

            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('opacity-0');
                setTimeout(() => messageBox.classList.add('hidden'), 300);
            }, duration);
        }

        async function connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    userAccount = accounts[0];

                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    contract = new ethers.Contract(contractAddress, JSON.parse(contractABI), signer);

                    connectionStatus.textContent = `Connected: ${userAccount.substring(0, 6)}...${userAccount.substring(userAccount.length - 4)}`;
                    connectionStatus.classList.add('text-green-600', 'font-semibold');
                    connectButton.textContent = 'Wallet Connected';
                    connectButton.disabled = true;
                    connectButton.classList.replace('bg-sky-600', 'bg-slate-400');
                    connectButton.classList.remove('hover:bg-sky-700');

                    actionsCard.classList.remove('hidden');
                    lookupCard.classList.remove('hidden');
                    historyDisplayCard.classList.remove('hidden');
                    showMessage('Wallet connected successfully!', 'success');

                    await loadAndDisplayAllBatchIds(); // Load batch IDs from blockchain

                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    window.ethereum.on('chainChanged', handleChainChanged);

                } catch (error) {
                    console.error("User denied account access or error:", error);
                    connectionStatus.textContent = 'Connection failed. Please try again.';
                    connectionStatus.classList.remove('text-green-600', 'font-semibold');
                    showMessage(`Connection Error: ${error.message || 'User denied access.'}`, 'error');
                }
            } else {
                connectionStatus.textContent = 'MetaMask is not installed. Please install it to use this app.';
                showMessage('MetaMask not detected. Please install MetaMask.', 'error');
                connectButton.disabled = true;
            }
        }

        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                showMessage('Wallet disconnected. Please connect MetaMask.', 'info');
                resetUI();
            } else {
                userAccount = accounts[0];
                connectionStatus.textContent = `Connected: ${userAccount.substring(0, 6)}...${userAccount.substring(userAccount.length - 4)}`;
                if (provider) {
                    signer = provider.getSigner();
                    contract = new ethers.Contract(contractAddress, JSON.parse(contractABI), signer);
                }
                showMessage('Account changed.', 'info');
                loadAndDisplayAllBatchIds();
            }
        }

        function handleChainChanged(_chainId) {
            showMessage('Network changed. Please ensure you are on Sepolia Testnet and refresh if needed.', 'info');
            window.location.reload();
        }

        function resetUI() {
            connectButton.textContent = 'Connect to MetaMask';
            connectButton.disabled = false;
            connectButton.classList.replace('bg-slate-400','bg-sky-600');
            connectButton.classList.add('hover:bg-sky-700');
            connectionStatus.textContent = 'Not Connected. Click to connect.';
            connectionStatus.classList.remove('text-green-600', 'font-semibold');
            actionsCard.classList.add('hidden');
            lookupCard.classList.add('hidden');
            historyDisplayCard.classList.add('hidden');
            previousBatchIdsSection.classList.add('hidden');
            previousBatchIdsList.innerHTML = '<p class="text-slate-500 italic text-sm">No batches registered yet in this session.</p>';
            fetchedBatchIds = [];
            userAccount = null;
            provider = null;
            signer = null;
            contract = null;
        }

        // Load and display all batch IDs from the blockchain
        async function loadAndDisplayAllBatchIds() {
            // Determine the contract instance to use (signed or read-only)
            let contractToUse = contract;
            if (!contractToUse) {
                try {
                    const readProvider = new ethers.providers.JsonRpcProvider('https://rpc.sepolia.org');
                    contractToUse = new ethers.Contract(contractAddress, JSON.parse(contractABI), readProvider);
                    // showMessage('Fetching batch ID list using a public node.', 'info', 2000);
                } catch (e) {
                    console.error("Error creating read-only provider for batch list:", e);
                    showMessage('Could not connect to blockchain to fetch batch ID list.', 'error');
                    previousBatchIdsList.innerHTML = '<p class="text-red-500 text-sm">Error fetching batch ID list.</p>';
                    previousBatchIdsSection.classList.remove('hidden');
                    return;
                }
            }

            if (!contractToUse || typeof contractToUse.getAllBatchIds !== 'function') {
                console.warn("getAllBatchIds function not found in ABI or contract not initialized.");
                previousBatchIdsList.innerHTML = '<p class="text-slate-500 italic text-sm">Contract function to list all Batch IDs is not available. Please check contract ABI and deployment.</p>';
                previousBatchIdsSection.classList.remove('hidden'); // Show the section with the message
                return;
            }

            try {
                previousBatchIdsList.innerHTML = '<p class="text-slate-500 italic text-sm">Loading Batch IDs from blockchain...</p>';
                previousBatchIdsSection.classList.remove('hidden');

                const ids = await contractToUse.getAllBatchIds();
                fetchedBatchIds = [...new Set(ids)]; // Ensure unique IDs
                updatePreviousBatchIdsListDOM();
            } catch (error) {
                console.error("Error fetching all batch IDs:", error);
                showMessage("Could not load list of all batch IDs from blockchain. Ensure the contract is deployed and has this function.", "error");
                previousBatchIdsList.innerHTML = '<p class="text-red-500 text-sm">Failed to load Batch IDs. Check console.</p>';
            }
        }

        // Updates the DOM with the fetchedBatchIds
        function updatePreviousBatchIdsListDOM() {
            previousBatchIdsSection.classList.remove('hidden'); // Ensure section is visible
            if (fetchedBatchIds.length > 0) {
                previousBatchIdsList.innerHTML = ''; // Clear existing
                fetchedBatchIds.forEach(id => {
                    if (!id || id.trim() === "") return; // Skip empty IDs
                    const listItem = document.createElement('div');
                    listItem.textContent = id;
                    listItem.classList.add('batch-id-list-item');
                    listItem.onclick = () => {
                        viewBatchIdInput.value = id;
                        viewHistory();
                    };
                    previousBatchIdsList.appendChild(listItem);
                });
            } else {
                previousBatchIdsList.innerHTML = '<p class="text-slate-500 italic text-sm">No Batch IDs found on the blockchain for this contract.</p>';
            }
        }

        async function registerNewBatch() {
            if (!contract) {
                showMessage('Please connect your wallet first.', 'error');
                return;
            }
            const batchId = batchIdInput.value.trim();
            const initialLocation = locationInput.value.trim();

            if (!batchId || !initialLocation) {
                showMessage('Batch ID and Initial Location are required.', 'error');
                return;
            }

            try {
                showMessage('Sending transaction to register batch...', 'info');
                const tx = await contract.registerBatch(batchId, initialLocation);
                await tx.wait();
                showMessage(`Batch "${batchId}" registered successfully! Tx: ${tx.hash.substring(0,10)}...`, 'success');

                // Refresh the list of all batch IDs from the blockchain
                await loadAndDisplayAllBatchIds();

                batchIdInput.value = '';
                locationInput.value = '';
            } catch (error) {
                console.error("Error registering batch:", error);
                showMessage(`Error registering batch: ${error?.data?.message || error.message || 'Transaction failed.'}`, 'error');
            }
        }

        async function addBatchUpdate() {
            if (!contract) {
                showMessage('Please connect your wallet first.', 'error');
                return;
            }
            const batchId = batchIdInput.value.trim(); // Use the same input for batch ID
            const newLocation = locationInput.value.trim(); // Use the same input for location

            if (!batchId || !newLocation) {
                showMessage('Batch ID and New Location are required for an update.', 'error');
                return;
            }

            try {
                showMessage('Sending transaction to update batch location...', 'info');
                const tx = await contract.addTrackingUpdate(batchId, newLocation);
                await tx.wait();
                showMessage(`Location for batch "${batchId}" updated! Tx: ${tx.hash.substring(0,10)}...`, 'success');
                locationInput.value = '';
            } catch (error) {
                console.error("Error updating batch:", error);
                showMessage(`Error updating batch: ${error?.data?.message || error.message || 'Transaction failed.'}`, 'error');
            }
        }

        async function viewHistory() {
            const batchId = viewBatchIdInput.value.trim();
            if (!batchId) {
                showMessage('Please enter a Batch ID to view its history.', 'error');
                historyOutput.innerHTML = `<p class="text-slate-500 italic">Please enter a Batch ID.</p>`;
                return;
            }

            historyOutput.innerHTML = '<p class="text-slate-500 italic">Fetching history...</p>';
            historyDisplayCard.classList.remove('hidden');

            let currentContract = contract;

            if (!currentContract) {
                try {
                    const readProvider = new ethers.providers.JsonRpcProvider('https://rpc.sepolia.org');
                    currentContract = new ethers.Contract(contractAddress, JSON.parse(contractABI), readProvider);
                    showMessage('Fetching history using a public node (read-only). Connect wallet to make transactions.', 'info', 3000);
                } catch (e) {
                    console.error("Error creating read-only provider:", e);
                    showMessage('Could not connect to blockchain to fetch history. Please connect your wallet or check network.', 'error');
                    historyOutput.innerHTML = `<p class="text-red-500">Could not connect to blockchain.</p>`;
                    return;
                }
            }

            try {
                const history = await currentContract.getBatchHistory(batchId);

                if (history.length === 0) {
                    historyOutput.innerHTML = `<p class="text-slate-600 font-semibold">No history found for Batch ID: <span class="text-sky-700">${batchId}</span></p><p class="text-sm text-slate-500 mt-1">Ensure the Batch ID is correct and has been registered on the Sepolia network with the contract address: <span class="font-mono text-xs">${contractAddress}</span></p>`;
                } else {
                    let html = `<h3 class="text-xl font-semibold text-sky-700 mb-3">Journey for Batch ID: ${batchId}</h3>`;
                    history.forEach((event, index) => {
                        html += `
                            <div class="history-item">
                                <p class="font-medium text-slate-700"><strong>${index === 0 ? 'Registered' : 'Update ' + index}:</strong> ${event.location}</p>
                                <p class="text-xs text-slate-500 mt-1"><strong>Time:</strong> ${new Date(event.timestamp * 1000).toLocaleString()}</p>
                                <p class="text-xs text-slate-500"><strong>Recorded By:</strong> <span class="font-mono">${event.actor}</span></p>
                            </div>
                        `;
                    });
                    historyOutput.innerHTML = html;
                }
            } catch (error) {
                console.error("Error viewing history:", error);
                showMessage(`Error viewing history: ${error.message || 'Could not fetch data.'}. Ensure Batch ID is correct and registered.`, 'error');
                historyOutput.innerHTML = `<p class="text-red-500">Error fetching history. Ensure Batch ID is correct and the contract is deployed on Sepolia.</p>`;
            }
        }

        // --- Event Listeners ---
        connectButton.addEventListener('click', connectWallet);
        registerButton.addEventListener('click', registerNewBatch);
        updateButton.addEventListener('click', addBatchUpdate);
        viewHistoryButton.addEventListener('click', viewHistory);

        window.addEventListener('load', async () => {
            if (window.ethereum && window.ethereum.selectedAddress) {
                connectionStatus.textContent = 'MetaMask detected. Previously connected. Click to re-connect.';
            } else if (window.ethereum) {
                 connectionStatus.textContent = 'MetaMask detected. Click "Connect Wallet" to begin.';
            } else {
                connectionStatus.textContent = 'MetaMask not detected. Please install MetaMask to use this DApp.';
                connectButton.disabled = true;
                connectButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
            if (actionsCard.classList.contains('hidden')) {
                 historyDisplayCard.classList.add('hidden');
            }
            // Attempt to load batch IDs on page load using a read-only provider if wallet not connected yet
            // This allows users to see the list even before connecting their wallet for interaction.
            await loadAndDisplayAllBatchIds();
        });

    </script>
</body>
</html>
