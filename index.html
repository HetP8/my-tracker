<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced34 Blockchain Tracker PoC</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        /* Custom font */
        body { font-family: 'Inter', sans-serif; /* Ensure Inter is loaded or use a common sans-serif */ }

        /* Base button styling */
        .btn {
            @apply inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-150;
        }
        .btn-primary { @apply bg-sky-600 hover:bg-sky-700 focus:ring-sky-500; }
        .btn-secondary { @apply bg-emerald-500 hover:bg-emerald-600 focus:ring-emerald-400; }
        .btn-neutral { @apply bg-slate-500 hover:bg-slate-600 focus:ring-slate-400; }
        .btn-disabled { @apply bg-slate-300 hover:bg-slate-300 cursor-not-allowed; }

        .input-field {
            @apply block w-full px-4 py-3 rounded-md border-slate-300 shadow-sm focus:border-sky-500 focus:ring focus:ring-sky-500 focus:ring-opacity-50 placeholder-slate-400 text-sm;
        }
        .card {
            @apply bg-white shadow-2xl rounded-xl p-6 sm:p-8 mb-8;
        }
        .history-item {
            @apply border-b border-slate-200 py-4;
        }
        .history-item:last-child { @apply border-b-0 pb-0; }
        .history-item p { @apply mb-1; }

        #messageBox {
            @apply fixed top-6 right-6 p-4 rounded-lg shadow-xl text-white z-[100] text-sm transition-all duration-300 ease-in-out transform translate-x-full opacity-0;
        }
        #messageBox.show {
            @apply translate-x-0 opacity-100;
        }
        .message-success { @apply bg-green-500; }
        .message-error { @apply bg-red-600; }
        .message-info { @apply bg-blue-500; }

        .batch-id-list-item {
            @apply block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-sky-100 hover:text-sky-700 rounded-md cursor-pointer transition-colors;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-50 text-slate-900 min-h-screen flex flex-col items-center pt-8 sm:pt-12 pb-20 px-4 selection:bg-sky-200 selection:text-sky-700">

    <div id="messageBox"></div>

    <div class="w-full max-w-3xl">
        <header class="text-center mb-10 sm:mb-12">
            <div class="inline-flex items-center justify-center mb-4">
                 <svg class="h-12 w-12 text-sky-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5V6.75a4.5 4.5 0 119 0v3.75M3.75 21.75h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H3.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z" />
                </svg>
                <h1 class="ml-3 text-4xl sm:text-5xl font-bold text-sky-600 tracking-tight">ChainTrack PoC</h1>
            </div>
            <p class="text-slate-600 mt-1 text-lg">Ethical Supply Chain Verification on the Blockchain (Sepolia Testnet)</p>
        </header>

        <div class="card">
            <h2 class="text-2xl font-semibold mb-3 text-sky-700">Welcome to ChainTrack PoC!</h2>
            <p class="text-slate-600 text-sm leading-relaxed mb-2">
                This Proof-of-Concept demonstrates a simplified blockchain-based supply chain tracking system.
                It allows for the registration of product batches and the recording of their movements or status updates
                on an immutable ledger (the Sepolia Ethereum testnet).
            </p>
            <p class="text-slate-600 text-sm leading-relaxed">
                <strong>How it works:</strong> Connect your MetaMask wallet (on Sepolia network). You can then register new batches with an initial location, or add tracking updates to existing batches. All transactions are recorded on the blockchain. You can view the history of any batch by its ID.
            </p>
             <p class="text-slate-600 text-sm leading-relaxed mt-2">
                <strong>For a Prospective Client:</strong> Imagine this system scaled up. Each product or batch gets a unique digital identity. Every step – from raw material sourcing, manufacturing, shipping, to retail – can be recorded transparently and securely. This enables:
                <ul class="list-disc list-inside ml-4 mt-1 text-slate-600 text-sm">
                    <li>Verification of product authenticity.</li>
                    <li>Proof of ethical sourcing and compliance (e.g., fair labor, conflict-free minerals).</li>
                    <li>Enhanced consumer trust and brand reputation.</li>
                    <li>Improved recall management and supply chain efficiency.</li>
                </ul>
            </p>
        </div>


        <div class="card" id="connectCard">
            <h2 class="text-2xl font-semibold mb-4 text-sky-700">1. Connect Your Wallet</h2>
            <button id="connectButton" class="btn btn-primary w-full text-lg">
                <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a2.25 2.25 0 00-2.25-2.25H15a3 3 0 11-6 0H5.25A2.25 2.25 0 003 12m18 0v6a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 18v-6m18 0V9M3 12V9m18 0a2.25 2.25 0 00-2.25-2.25H5.25A2.25 2.25 0 003 6.75m15.75 0V5.25A2.25 2.25 0 0016.5 3h-9A2.25 2.25 0 005.25 5.25v1.5" /></svg>
                Connect to MetaMask
            </button>
            <p id="connectionStatus" class="mt-4 text-sm text-center text-slate-500">Please connect to the Sepolia Testnet.</p>
        </div>

        <div id="mainAppInterface" class="hidden">
            <div class="card">
                <h2 class="text-2xl font-semibold mb-1 text-sky-700">2. Register or Update Batch</h2>
                <p class="text-sm text-slate-500 mb-6">Enter batch details below. All actions require a transaction on the Sepolia network.</p>

                <div>
                    <label for="batchId" class="block text-sm font-medium text-slate-700 mb-1">Batch ID (Unique Identifier):</label>
                    <input type="text" id="batchId" name="batchId" class="input-field" placeholder="e.g., COFFEE-XYZ-001">
                </div>

                <div class="mt-4">
                    <label for="location" class="block text-sm font-medium text-slate-700 mb-1">Location / Status / Details:</label>
                    <input type="text" id="location" name="location" class="input-field" placeholder="e.g., Origin: Nyeri, Kenya / Warehouse A Scan">
                </div>

                <div class="mt-6 grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <button id="registerButton" class="btn btn-primary w-full">Register New Batch</button>
                    <button id="updateButton" class="btn btn-secondary w-full">Add Tracking Update</button>
                </div>
            </div>

            <div class="card">
                <h2 class="text-2xl font-semibold mb-4 text-sky-700">3. Registered Batch IDs</h2>
                <div id="allBatchIdsList" class="max-h-60 overflow-y-auto bg-slate-50 p-3 rounded-md border border-slate-200">
                    <p class="text-slate-500 italic">Loading batch IDs or no batches registered yet...</p>
                </div>
            </div>

            <div class="card">
                <h2 class="text-2xl font-semibold mb-4 text-sky-700">4. View Specific Batch History</h2>
                <div>
                    <label for="viewBatchId" class="block text-sm font-medium text-slate-700 mb-1">Batch ID to View:</label>
                    <input type="text" id="viewBatchId" name="viewBatchId" class="input-field" placeholder="Enter Batch ID or click one from the list above">
                </div>
                <button id="viewHistoryButton" class="btn btn-neutral mt-4 w-full">View History</button>

                <div id="historyOutput" class="mt-6 pt-6 border-t border-slate-200">
                    <p class="text-slate-500 italic">Enter a Batch ID and click "View History" or select from the list above.</p>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center mt-12 mb-6">
        <p class="text-sm text-slate-500">&copy; ${new Date().getFullYear()} ChainTrack PoC. For demonstration purposes only.</p>
    </footer>

    <script>
        // --- Configuration ---
        const contractAddress = '0xd9145CCE52D386f254917e481eB44e9943F39138'; // This is from your file, ensure it's correct
        const contractABI = \`[
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "_newLocation",
				"type": "string"
			}
		],
		"name": "addTrackingUpdate",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "string",
				"name": "batchId",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "newLocation",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "updatedBy",
				"type": "address"
			}
		],
		"name": "BatchLocationUpdated",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "string",
				"name": "batchId",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "initialLocation",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "registeredBy",
				"type": "address"
			}
		],
		"name": "BatchRegistered",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			},
			{
				"internalType": "string",
				"name": "_initialLocation",
				"type": "string"
			}
		],
		"name": "registerBatch",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "allBatchIds",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "batchHistory",
		"outputs": [
			{
				"internalType": "string",
				"name": "location",
				"type": "string"
			},
			{
				"internalType": "uint256",
				"name": "timestamp",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "actor",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getAllBatchIds",
		"outputs": [
			{
				"internalType": "string[]",
				"name": "",
				"type": "string[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			}
		],
		"name": "getBatchHistory",
		"outputs": [
			{
				"components": [
					{
						"internalType": "string",
						"name": "location",
						"type": "string"
					},
					{
						"internalType": "uint256",
						"name": "timestamp",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "actor",
						"type": "address"
					}
				],
				"internalType": "struct TrackerV2.TrackingEvent[]",
				"name": "",
				"type": "tuple[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_batchId",
				"type": "string"
			}
		],
		"name": "getHistoryCount",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
]\`; // This is from your file, ensure it's correct

        // --- Global Variables ---
        let provider;
        let signer;
        let contract;
        let userAccount;

        // --- DOM Elements ---
        const connectButton = document.getElementById('connectButton');
        const connectionStatus = document.getElementById('connectionStatus');
        const mainAppInterface = document.getElementById('mainAppInterface');

        const batchIdInput = document.getElementById('batchId');
        const locationInput = document.getElementById('location');
        const registerButton = document.getElementById('registerButton');
        const updateButton = document.getElementById('updateButton');

        const allBatchIdsList = document.getElementById('allBatchIdsList');
        const viewBatchIdInput = document.getElementById('viewBatchId');
        const viewHistoryButton = document.getElementById('viewHistoryButton');
        const historyOutput = document.getElementById('historyOutput');
        const messageBox = document.getElementById('messageBox');

        // --- Functions --- (showMessage, connectWallet, handleAccountsChanged, handleChainChanged, resetUI, registerNewBatch, addBatchUpdate, fetchAllBatchIds, displayAllBatchIds, viewHistory - these should all be the same as the previous correct version)

        function showMessage(text, type = 'info', duration = 5000) {
            messageBox.textContent = text;
            messageBox.className = 'fixed top-6 right-6 p-4 rounded-lg shadow-xl text-white z-[100] text-sm transition-all duration-300 ease-in-out transform opacity-0'; // Reset classes
            
            if (type === 'success') messageBox.classList.add('message-success');
            else if (type === 'error') messageBox.classList.add('message-error');
            else messageBox.classList.add('message-info');
            
            void messageBox.offsetWidth; 
            messageBox.classList.add('show');

            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        async function connectWallet() {
            // Check if the button is already disabled (e.g. from a previous failed attempt or if already connected)
            // This check was slightly different in the uploaded file, ensure it matches this logic
            if (connectButton.disabled && connectButton.textContent === 'Wallet Connected') {
                 console.log("Wallet already connected and initialized.");
                 return; // Already connected
            }
            if (connectButton.disabled && connectButton.textContent !== 'Wallet Connected') {
                 console.log("Connect button is disabled, likely due to MetaMask not being detected initially.");
                 // Optionally, re-check for MetaMask here if desired, or rely on user refresh
                 if (typeof window.ethereum === 'undefined') {
                    showMessage('MetaMask not detected. Please install MetaMask and refresh.', 'error');
                    return;
                 }
            }


            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    userAccount = accounts[0];
                    
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    // Ensure ABI is parsed correctly
                    let parsedABI;
                    try {
                        parsedABI = JSON.parse(contractABI);
                    } catch (e) {
                        console.error("Failed to parse Contract ABI:", e);
                        showMessage("Critical Error: Contract ABI is invalid. Check console.", "error");
                        return;
                    }
                    contract = new ethers.Contract(contractAddress, parsedABI, signer);
                    
                    connectionStatus.innerHTML = \`Connected: <span class="font-semibold">\${userAccount.substring(0, 6)}...\${userAccount.substring(userAccount.length - 4)}</span> on Sepolia\`;
                    connectButton.textContent = 'Wallet Connected';
                    connectButton.disabled = true;
                    connectButton.classList.remove('btn-primary');
                    connectButton.classList.add('btn-disabled');
                    
                    document.getElementById('connectCard').classList.add('hidden');
                    mainAppInterface.classList.remove('hidden');
                    showMessage('Wallet connected successfully!', 'success');

                    await fetchAllBatchIds(); 

                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    window.ethereum.on('chainChanged', handleChainChanged);

                } catch (error) {
                    console.error("User denied account access or error during connectWallet:", error);
                    connectionStatus.textContent = 'Connection failed. Please try again.';
                    showMessage(\`Connection Error: \${error.message || 'User denied access.'}\`, 'error');
                }
            } else {
                connectionStatus.textContent = 'MetaMask is not installed. Please install it to use this app.';
                showMessage('MetaMask not detected. Please install MetaMask and refresh.', 'error');
                connectButton.disabled = true; 
                connectButton.classList.remove('btn-primary');
                connectButton.classList.add('btn-disabled');
            }
        }

        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                showMessage('Wallet disconnected. Please connect MetaMask.', 'info');
                resetUI();
            } else {
                userAccount = accounts[0];
                connectionStatus.innerHTML = \`Connected: <span class="font-semibold">\${userAccount.substring(0, 6)}...\${userAccount.substring(userAccount.length - 4)}</span> on Sepolia\`;
                if (provider) {
                    signer = provider.getSigner();
                    // Ensure ABI is parsed correctly
                    let parsedABI;
                    try {
                        parsedABI = JSON.parse(contractABI);
                    } catch (e) {
                        console.error("Failed to parse Contract ABI during accountsChanged:", e);
                        showMessage("Critical Error: Contract ABI is invalid. Check console.", "error");
                        return;
                    }
                    contract = new ethers.Contract(contractAddress, parsedABI, signer);
                }
                showMessage('Account changed.', 'info');
                fetchAllBatchIds(); 
            }
        }

        function handleChainChanged(_chainId) {
            showMessage('Network changed. Please ensure you are on Sepolia Testnet and refresh if needed.', 'info');
            window.location.reload();
        }
        
        function resetUI() {
            connectButton.textContent = 'Connect to MetaMask';
            connectButton.disabled = false;
            connectButton.classList.add('btn-primary');
            connectButton.classList.remove('btn-disabled');
            connectionStatus.textContent = 'Please connect to the Sepolia Testnet.';
            mainAppInterface.classList.add('hidden');
            document.getElementById('connectCard').classList.remove('hidden');
            userAccount = null;
            provider = null;
            signer = null;
            contract = null;
        }

        async function registerNewBatch() {
            if (!contract) { showMessage('Please connect your wallet first.', 'error'); return; }
            const batchId = batchIdInput.value.trim();
            const initialLocation = locationInput.value.trim();

            if (!batchId || !initialLocation) { showMessage('Batch ID and Initial Location are required.', 'error'); return; }

            registerButton.disabled = true;
            registerButton.textContent = 'Registering...';
            try {
                showMessage('Sending transaction to register batch...', 'info');
                const tx = await contract.registerBatch(batchId, initialLocation);
                await tx.wait();
                showMessage(\`Batch "\${batchId}" registered successfully! Tx: \${tx.hash.substring(0,10)}...\`, 'success');
                batchIdInput.value = '';
                locationInput.value = '';
                await fetchAllBatchIds(); 
            } catch (error) {
                console.error("Error registering batch:", error);
                let errMsg = error?.data?.message || error?.error?.message || error.message || 'Transaction failed.';
                if (typeof errMsg === 'object') errMsg = JSON.stringify(errMsg);
                if (errMsg.includes("Batch ID already exists")) errMsg = "This Batch ID has already been registered.";
                showMessage(\`Error: \${errMsg}\`, 'error');
            } finally {
                registerButton.disabled = false;
                registerButton.textContent = 'Register New Batch';
            }
        }

        async function addBatchUpdate() {
            if (!contract) { showMessage('Please connect your wallet first.', 'error'); return; }
            const batchId = batchIdInput.value.trim();
            const newLocation = locationInput.value.trim();

            if (!batchId || !newLocation) { showMessage('Batch ID and New Location are required for an update.', 'error'); return; }
            
            updateButton.disabled = true;
            updateButton.textContent = 'Updating...';
            try {
                showMessage('Sending transaction to update batch location...', 'info');
                const tx = await contract.addTrackingUpdate(batchId, newLocation);
                await tx.wait();
                showMessage(\`Location for batch "\${batchId}" updated! Tx: \${tx.hash.substring(0,10)}...\`, 'success');
                locationInput.value = ''; 
                if (viewBatchIdInput.value.trim() === batchId) {
                    await viewHistory();
                }
            } catch (error) {
                console.error("Error updating batch:", error);
                let errMsg = error?.data?.message || error?.error?.message || error.message || 'Transaction failed.';
                if (typeof errMsg === 'object') errMsg = JSON.stringify(errMsg);
                if (errMsg.includes("Batch ID not found")) errMsg = "Batch ID not found. Register it first.";
                showMessage(\`Error: \${errMsg}\`, 'error');
            } finally {
                updateButton.disabled = false;
                updateButton.textContent = 'Add Tracking Update';
            }
        }
        
        async function fetchAllBatchIds() {
            let tempContract = contract;
            if (!tempContract) {
                 try {
                    const readProvider = new ethers.providers.JsonRpcProvider(\`https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID\`); // Replace with your Infura ID
                    // Ensure ABI is parsed correctly
                    let parsedABI;
                    try {
                        parsedABI = JSON.parse(contractABI);
                    } catch (e) {
                        console.error("Failed to parse Contract ABI during fetchAllBatchIds (read-only):", e);
                        allBatchIdsList.innerHTML = '<p class="text-red-500 italic">Critical Error: ABI invalid.</p>';
                        return;
                    }
                    tempContract = new ethers.Contract(contractAddress, parsedABI, readProvider);
                } catch(e) {
                    allBatchIdsList.innerHTML = '<p class="text-red-500 italic">Could not load batch IDs. Connect wallet or check console.</p>';
                    console.error("Error creating read-only provider for fetchAllBatchIds:", e);
                    return;
                }
            }

            try {
                allBatchIdsList.innerHTML = '<p class="text-slate-500 italic">Loading batch IDs...</p>';
                const ids = await tempContract.getAllBatchIds(); 
                displayAllBatchIds(ids);
            } catch (error) {
                console.error("Error fetching all batch IDs:", error);
                allBatchIdsList.innerHTML = '<p class="text-red-500 italic">Failed to load batch IDs. Ensure your wallet is connected to Sepolia.</p>';
            }
        }

        function displayAllBatchIds(ids) {
            if (!ids || ids.length === 0) { // Added !ids check
                allBatchIdsList.innerHTML = '<p class="text-slate-500 italic">No batches registered yet.</p>';
                return;
            }
            allBatchIdsList.innerHTML = ''; 
            const ul = document.createElement('ul');
            ul.className = 'space-y-1';
            ids.forEach(id => {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = id;
                button.className = 'batch-id-list-item';
                button.onclick = () => {
                    viewBatchIdInput.value = id;
                    viewHistory();
                    document.getElementById('historyOutput').scrollIntoView({ behavior: 'smooth', block: 'start' });
                };
                li.appendChild(button);
                ul.appendChild(li);
            });
            allBatchIdsList.appendChild(ul);
        }

        async function viewHistory() {
            let currentReaderContract = contract; 
            let batchIdToView = viewBatchIdInput.value.trim();

            if (!batchIdToView) {
                showMessage('Please enter a Batch ID to view its history.', 'error');
                return;
            }
            
            historyOutput.innerHTML = '<p class="text-slate-500 italic">Fetching history...</p>';

            if (!currentReaderContract) {
                try {
                    const readProvider = new ethers.providers.JsonRpcProvider(\`https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID\`); // Replace with your Infura ID
                    // Ensure ABI is parsed correctly
                    let parsedABI;
                    try {
                        parsedABI = JSON.parse(contractABI);
                    } catch (e) {
                        console.error("Failed to parse Contract ABI during viewHistory (read-only):", e);
                        historyOutput.innerHTML = '<p class="text-red-500">Critical Error: ABI invalid.</p>';
                        return;
                    }
                    currentReaderContract = new ethers.Contract(contractAddress, parsedABI, readProvider);
                } catch (e) {
                    console.error("Error creating read-only provider for viewHistory:", e);
                    showMessage('Cannot view history. Wallet not connected and no fallback provider configured.', 'error');
                    historyOutput.innerHTML = '<p class="text-red-500">Error: Wallet not connected and no fallback provider.</p>';
                    return;
                }
            }

            try {
                const history = await currentReaderContract.getBatchHistory(batchIdToView);
                
                if (!history || history.length === 0) { // Added !history check
                    historyOutput.innerHTML = \`<p class="text-slate-600 font-semibold">No history found for Batch ID: \${batchIdToView}</p>\`;
                } else {
                    let html = \`<h3 class="text-xl font-semibold text-sky-600 mb-3">History for Batch ID: \${batchIdToView}</h3>\`;
                    history.forEach((event, index) => {
                        html += \`
                            <div class="history-item">
                                <p class="text-sm"><strong class="font-medium text-slate-700">Event \${index + 1}:</strong> \${event.location}</p>
                                <p class="text-xs text-slate-500"><strong>Time:</strong> \${new Date(event.timestamp * 1000).toLocaleString()}</p>
                                <p class="text-xs text-slate-500"><strong>Recorded By:</strong> \${event.actor.substring(0,6)}...\${event.actor.substring(event.actor.length - 4)}</p>
                            </div>
                        \`;
                    });
                    historyOutput.innerHTML = html;
                }
            } catch (error) {
                console.error("Error viewing history:", error);
                showMessage(\`Error viewing history: \${error.message || 'Could not fetch data.'}\`, 'error');
                historyOutput.innerHTML = \`<p class="text-red-500">Error fetching history for "\${batchIdToView}". Ensure Batch ID is correct and registered.</p>\`;
            }
        }

        // --- Event Listeners ---
        // Ensure connectButton is not null before adding listener
        if (connectButton) {
            connectButton.addEventListener('click', connectWallet);
        } else {
            console.error("Connect button not found on page load for event listener attachment.");
        }
        // Same for other buttons if needed, though less likely to be null if HTML structure is correct
        if (registerButton) registerButton.addEventListener('click', registerNewBatch);
        if (updateButton) updateButton.addEventListener('click', addBatchUpdate);
        if (viewHistoryButton) viewHistoryButton.addEventListener('click', viewHistory);


        // ***** THIS IS THE CRITICAL BLOCK TO UPDATE *****
        window.addEventListener('load', () => {
            // Give MetaMask a brief moment to inject window.ethereum
            setTimeout(() => {
                const localConnectButton = document.getElementById('connectButton'); // Re-fetch inside timeout
                const localConnectionStatus = document.getElementById('connectionStatus'); // Re-fetch

                if (!localConnectButton || !localConnectionStatus) {
                    console.error("Connect button or status element not found during load event. HTML might not be fully parsed.");
                    return; 
                }

                if (window.ethereum) {
                    localConnectionStatus.textContent = 'MetaMask detected. Click the button above to connect.';
                    if (window.ethereum.selectedAddress && window.ethereum.isConnected()) {
                        localConnectionStatus.innerHTML = \`MetaMask detected. Previously connected as <span class="font-semibold">\${window.ethereum.selectedAddress.substring(0, 6)}...\${window.ethereum.selectedAddress.substring(window.ethereum.selectedAddress.length - 4)}</span>. Click to re-initialize if needed.\`;
                    }
                    localConnectButton.disabled = false; 
                    localConnectButton.classList.add('btn-primary');
                    localConnectButton.classList.remove('btn-disabled');
                } else {
                    localConnectionStatus.textContent = 'MetaMask not detected. Please install MetaMask and refresh the page.';
                    localConnectButton.disabled = true; 
                    localConnectButton.classList.remove('btn-primary');
                    localConnectButton.classList.add('btn-disabled');
                    // Only show error message if it hasn't been shown already for this
                    if (!document.body.dataset.metaMaskErrorShown) {
                        showMessage('MetaMask not detected. Please install it and refresh.', 'error');
                        document.body.dataset.metaMaskErrorShown = "true"; 
                    }
                }
            }, 500); // Wait 500ms for MetaMask to inject
        });

    </script>
</body>
</html>

